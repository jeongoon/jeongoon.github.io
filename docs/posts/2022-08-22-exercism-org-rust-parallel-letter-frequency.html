<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" class="font-sans">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="author" content="Myoungjin Jeon">


    <meta name="description" content="Introduction to concurrent programming in rust">


    <meta name="keywords" content="rust, parallel, concurrency, channel">

   <!-- even though I setup @media to make change all the fixed font size;
        FF on mobile -- incorrectly -- scales font size again.
        This happends when:

        1. default font size variable (ex: 2vw, 3.5vw)
        2. the width of some division is larger than original width of website
           should be (or designed to be)
        3. now we have larger webstie width and mobile webbrowser scale down the
           website
        4. now we have too small size font
        5. FF scales up the font, which is irrelevant to the other normal divs.

     so I ended up re-insert below meta line again to correct them.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>MJ's kind weird Code - Exercism - Rust - Parallel Letter Frequency</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Atma:wght@300;500;700&family=Barlow+Condensed:ital,wght@0,100;0,300;0,600;1,100;1,500;1,600&family=Gamja+Flower&family=Hubballi&family=Jost:ital,wght@0,100;0,300;0,500;0,800;1,100;1,300;1,500;1,800&family=Unica+One&display=swap');
    </style> 
    <link rel="stylesheet" type="text/css" href="../css/19Apr2022.css" />
    <link rel="stylesheet" type="text/css" href="../css/12Apr2022.code.css" />
  </head>
  <body class="surface-color">
    <header id="main-header">
      <div id="logo" class="font-atma primary-color">
        <a href="../">MJ's Kind Weird Code</a>
      </div>
      <div id="page-title">
        <p> 📰 Exercism - Rust - Parallel Letter Frequency
        </p>
      </div>
      <nav id="main-nav" class="font-menu-title">
        <a href="../">Home</a>
        <a href="../about.html">About</a>
        <a href="../contact.html">Contact</a>
        <a href="../drafts.html">Drafts</a>
        <a href="../archive.html">Archive</a>
      </nav>
    </header>

    <div id="content" class="font-friendly">
            <div class="info">
    Posted on August 22, 2022
    
        by Myoungjin Jeon
    
</div>
<div class="info">
  
  Tags: <a title="All pages tagged 'rust'." href="../tags/rust.html">rust</a>, <a title="All pages tagged 'parallel'." href="../tags/parallel.html">parallel</a>, <a title="All pages tagged 'concurrency'." href="../tags/concurrency.html">concurrency</a>, <a title="All pages tagged 'channel'." href="../tags/channel.html">channel</a>
  
</div>

<h2 id="brief-introductions-not-original">Brief Introductions (not original)</h2>
<p>Count the frequency of letters stored in <em>a</em> list of <code class="verbatim">&amp;str</code>. i.e:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> frequency(input<span class="op">:</span> <span class="op">&amp;</span>[<span class="op">&amp;</span><span class="dt">str</span>]<span class="op">,</span> worker_count<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> HashMap<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">usize</span><span class="op">&gt;</span></span></code></pre></div>
<p>Moreover, we need depoly workers(thread) which is specified as <code>worker_count</code>. This requirement
makes this task exciting and challenging as I have little exprience on concurrency programming.
And original introduction also suggests:</p>
<blockquote>
<p>Learn more about concurrency in Rust here: <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">Concurrency</a></p>
</blockquote>
<p>Which covers general knowledge about concurrency enough to understand to solve the task!</p>
<h2 id="working-on-concurrency">Working on concurrency</h2>
<p>Breifely, we are using concurrent programming because to get</p>
<blockquote>
<ul>
<li>Parallel - Do the <em>similar</em> or same job <strong>at the same</strong> time to <em>save time</em>.</li>
<li>Concurrency - Separate the jobs into different parts.</li>
</ul>
</blockquote>
<p>The task is about the former case. And the latter case is related to almost every programming
related to dynamic I/O to interact with user or other service.</p>
<p>Now we should think about how to:</p>
<blockquote>
<ul>
<li>Communicate between threads</li>
<li>Devide the task properly to make them work smooth and seemlessly</li>
</ul>
</blockquote>
<p>The first thing is most important here because if we don’t know how to communicate each other,
we could not achieve common goal, counting <em>whole</em> string. So how to talk to each others?</p>
<h2 id="how-to-make-thread-and-how-to-reap-them">How To Make Thread and How To Reap them</h2>
<p>Oh, wait… I found that we need to talk about how to make thread(s) and harvest the threads.
This is the first example on rust documentation</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::time::</span>Duration<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> _handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..</span><span class="dv">10</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;hi number {} from the spawned thread!&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_millis(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// note: there is no return value here: return value is not essential.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..</span><span class="dv">5</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;hi number {} from the main thread!&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_millis(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>And the result:</p>
<div class="sourceCode" id="cb3" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 1 from the main thread!</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 1 from the spawned thread!</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 2 from the main thread!</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 2 from the spawned thread!</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 3 from the main thread!</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 3 from the spawned thread!</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 4 from the main thread!</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 4 from the spawned thread!</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 5 from the spawned thread!</span></code></pre></div>
<h2 id="oh-no-we-should-wait-for-our-friends">oh no! we should wait for our friends!</h2>
<p>Does it look good? doesn’t is? But if we look carefully. we can find that some output is
missing as the our spawned thread is supposed to print up to <strong>9</strong>, but we only got 5 here.</p>
<div class="sourceCode" id="cb4" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hi</span> number 5 from the spawned thread!</span></code></pre></div>
<p>This is because main thread reach the end of block before the children thread finished its job.</p>
<p>We should have waited for our friend threads to see all the output.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// .. snip ..</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..</span><span class="dv">5</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;hi number {} from the main thread!&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_millis(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    _handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span> <span class="co">// wait until for the children thread to join to current thread.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h3 id="what-join-returns">What join() returns</h3>
<ul>
<li>type of last evaluation</li>
<li>we can use it for the result of the task as well.</li>
</ul>
<h2 id="communication-between-threads-in-rust">Communication Between threads in rust</h2>
<h3 id="return-value-from-thread">return value from thread</h3>
<p>I could see many other’s solution at exercism which is using return value from the
each thread after submitting the my first solution. And I found the major pros and
– maybe – cons from using the return value:</p>
<ul>
<li>pros: similar approach to normal function call (no extra setup)</li>
<li>??: the main thread is required to choose to which thread the main talks</li>
</ul>
<p>The latter sentence could be cons. let’s think about what kind of worst senario might look like:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sample <span class="op">=</span> <span class="op">&amp;</span>[<span class="st">&quot;very long string. abcdefghijklmnopqrstuvxyz...&quot;</span><span class="op">,</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>               <span class="st">&quot;&quot;</span><span class="op">,</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>               <span class="st">&quot;some more text&quot;</span><span class="op">,</span> ]<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// snip ..</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> total <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    our_counting_fold_fn(total<span class="op">,</span> handle<span class="op">.</span>join()<span class="op">.</span>unwrap())<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">// snip ..</span></span></code></pre></div>
<p>So, clearly, the first employee need to work harder than other 😂.
And we can see if the the diffrence between the lengths of the strings is larger,
the longer time will be <em>wasted</em> by last two cases and the <em>main</em> thread to wait only for
first thread to finished the job. <em>i.e: we lost the chance to summerize other results only to wait for first result.</em></p>
<p>So, if the main thread could not figure out how to <em>choose</em> right thread, the performance
in total isn’t great: no benefit from the thread at all.</p>
<h3 id="shared-memory">Shared memory</h3>
<p>I found the sentence shown below from the original <a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html">documentation</a>.</p>
<blockquote>
<p>access the same shared data. Consider this part of the slogan from the
Go language documentation again: “do not communicate by sharing memory.”</p>
</blockquote>
<p>However, Rust language would not say those in the same nuance because it seems that
rust ownership will deal with shared-memory very well.</p>
<blockquote>
<p>Management of mutexes can be incredibly tricky to get right, which is why so many people are enthusiastic about channels. However, thanks to Rust’s type system and ownership rules, you can’t get locking and unlocking wrong.</p>
</blockquote>
<p>Sounds promising, I hope I can go further on this subject later some time.</p>
<p>By the way, <em>Mutex is an abbreviation for mutual exclusion</em>.</p>
<p>Nevetheless, my first impression on shared-memory in concurrency are:</p>
<blockquote>
<ul>
<li>it is optional</li>
<li>less efficient</li>
<li>more complicated than any other method</li>
<li>but it is still useuful when requirement of multi ownership comes in.</li>
</ul>
</blockquote>
<p>And the execuses 😱 why I’d like to skip the method in this task are:</p>
<blockquote>
<ul>
<li>Less over-head is preferred in this simple task.</li>
<li>Yet, one thread is enought to summerize the results from others</li>
</ul>
</blockquote>
<h2 id="message-passing-via-channel">Message Passing via channel</h2>
<p>let’s check outh why many people are enthusiastic about message passing.</p>
<p><a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">The document of message passing(channel)</a> starts with the sentence like below:</p>
<blockquote>
<p>One increasingly popular approach to ensuring safe concurrency is message passing</p>
</blockquote>
<p>We can safely assume that the message passing as a recommended method for communicating, can’t we?</p>
<p>There is one more thing we need to think about before going further to solve the task</p>
<h2 id="ownership-matters">ownership matters</h2>
<p>The key difference between “message passing” and “shared-memory” is the number of ownership.
and message passing allows only one ownership at a time which gurantees
the receiver could get the consistent result as it won’t be allowed for sender to access
the value after sending them. It may sounds tedious at first.
What if the value could be touched after sending them? the answer is simple:</p>
<blockquote>
<p>We cannot gurantee the what will happen</p>
</blockquote>
<p>The unpredictable is most dangerous thing in programming world, nobody would want that
unless we are throwing a dice.</p>
<p>I felt that <em>rust documentation is quite logical</em>. please read more on <a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">The original book</a>.</p>
<h2 id="how-to-make-channel">How to make channel</h2>
<h3 id="one-on-one">one on one</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span>mpsc<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (tx<span class="op">,</span> rx) <span class="op">=</span> <span class="pp">mpsc::</span>channel()<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> val <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hi&quot;</span>)<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// sending from the friend thread</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        tx<span class="op">.</span>send(val)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span> <span class="co">// return value is not quite useful here so it is in void context</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// no `let` statement or no following function(method call) after that.</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// receiving from the main thread</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> received <span class="op">=</span> rx<span class="op">.</span>recv()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Got: {}&quot;</span><span class="op">,</span> received)<span class="op">;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="many-speakers-and-only-one-listener">many speakers and only one listener</h3>
<p>Now I’d like to remind you that we have actually many workers who want to talk about
their accomplishment with their works.</p>
<p>But if <code class="verbatim">tx</code> variable is moved to one thread, we cannot use it in another thread. This has
something with the simple principle in rust after all. <strong>ownership</strong>.</p>
<p>So we need to clone them as much as we need. This process is relatively simple:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// .. snip ..</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (tx_main<span class="op">,</span> rx_main) <span class="op">=</span> <span class="pp">mpsc::</span>channel()<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> handles <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">// .. snip ..</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span><span class="op">..</span>worker_count)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>for_each(<span class="op">|</span>_<span class="op">|</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> tx <span class="op">=</span> tx_main<span class="op">.</span>clone()<span class="op">;</span> <span class="co">// this is it. simple and easy</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// now tx is only available in this thread only</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// as its ownership is moved here.</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        handles<span class="op">.</span>push(handle)<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">// .. snip ..</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h3 id="my-first-collecting-the-partial-results-is-not-working">my first collecting the partial results is not working</h3>
<p>The example code in rust shows me how to read from receiver(rx_main).
But unknown reason makes the following code runs infinitely.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    rx_main</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>into_iter()</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>fold(<span class="pp">HashMap::</span>new()<span class="op">,</span> <span class="op">|</span><span class="kw">mut</span> acc<span class="op">,</span> partial_acc<span class="op">|</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>            partial_acc</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>iter()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>for_each(<span class="op">|</span>(<span class="op">&amp;</span>ch<span class="op">,</span> <span class="op">&amp;</span>count)<span class="op">|</span> <span class="kw">match</span> acc<span class="op">.</span>entry(ch) <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                    Occupied(o) <span class="op">=&gt;</span> <span class="op">*</span>o<span class="op">.</span>into_mut() <span class="op">+=</span> count<span class="op">,</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                    Vacant(v) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                        v<span class="op">.</span>insert(count)<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            acc</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So.. I had to drop the code which directly iterating from the receiver,
I rather go with the following approach:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// note: the following code works only one main thread.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span><span class="op">..</span>worker_count) <span class="co">// use it for only numbering the iteration</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>for_each(<span class="op">|</span>_id<span class="op">|</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        rx_main</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>recv() <span class="co">// like when I did for single read.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  .somefunc() ... and summerizing(folding) go around here</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span></code></pre></div>
<p>I know this is not perfect reading because it only takes one value per thread.
what if each thread talks more than one?
<em>It works so far, I apoligize that if it is not enough explanation. I will come back forthis if I found the reason and workaround for it.</em></p>
<h2 id="dividing-the-tasks">Dividing the tasks</h2>
<p>It is time to give the threads something to work with. we need to divide our job into
a certain amount of smaller pieces so that you can hand them over the our workers(threads).</p>
<p>We’ll get the fixed amount of input data, so I decided:</p>
<ul>
<li>Divide the the list into as many as the number of workers and store it into</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// example: &amp;[&amp;str] -&gt; Vec&lt;Vec&lt;String&gt;&gt;  with two workers</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">&amp;</span>[ <span class="st">&quot;abc&quot;</span><span class="op">,</span> <span class="st">&quot;def&quot;</span><span class="op">,</span> <span class="st">&quot;ghi&quot;</span><span class="op">,</span> <span class="st">&quot;jkl&quot;</span> ]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>   <span class="co">// -&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a> <span class="pp">vec!</span>[</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;abcghi&quot;</span><span class="op">,</span> <span class="co">// note stored in String</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;defjkl&quot;</span><span class="op">,</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a> ]</span></code></pre></div>
<ul>
<li><em>Move</em> the each vector to the <em>one</em> appropriate thread.</li>
</ul>
<h3 id="the-partial-code-so-far">The partial code so far</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> frequency(input<span class="op">:</span> <span class="op">&amp;</span>[<span class="op">&amp;</span><span class="dt">str</span>]<span class="op">,</span> worker_count<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> HashMap<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">usize</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> num_workers <span class="op">=</span> <span class="kw">if</span> worker_count <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span> <span class="dv">1</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> worker_count <span class="op">};</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> handles <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// make a channel for all the results collected</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (tx_main<span class="op">,</span> rx_main) <span class="op">=</span> <span class="pp">mpsc::</span>channel()<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> input_per_worker <span class="op">=</span> <span class="pp">vec!</span>[<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;&quot;</span>)<span class="op">;</span> num_workers]<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    input</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter()</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>zip((<span class="dv">0</span><span class="op">..</span>worker_count)<span class="op">.</span>cycle()) <span class="co">// .cycle() easy way to rotate</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">//  the numbers</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>for_each(<span class="op">|</span>(<span class="op">&amp;</span>s<span class="op">,</span> i)<span class="op">|</span> <span class="op">{</span> <span class="co">// ( string as &amp;str, index(or id) number )</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>input_per_worker<span class="op">.</span>get_mut(i) <span class="co">// access the value at the index `i`</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>unwrap() <span class="co">// it is safe to access because we allocate the</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                          <span class="co">// memory space already</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">+=</span> s<span class="op">;</span>     <span class="co">// this very efficient way to copy the string from</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                          <span class="co">// a &amp;str</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    input_per_worker<span class="op">.</span>into_iter()<span class="op">.</span>for_each(<span class="op">|</span>input_<span class="op">|</span> <span class="op">{</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// preprare for sending</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> tx <span class="op">=</span> tx_main<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// prepare for listening</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// collect count</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> subtotal <span class="op">=</span> <span class="pp">HashMap::</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">usize</span><span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>            input_<span class="op">.</span>iter()<span class="op">.</span>for_each(<span class="op">|</span>s<span class="op">|</span> <span class="op">{</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>                <span class="co">// snip ..</span></span></code></pre></div>
<h3 id="benefits-from-memory-access">benefits from memory access</h3>
<p><code class="verbatim">input_per_worker.get_mut(i)</code> is a great inheritance from the memory access. In haskell,
maybe generating with lazy evaluation is better approach for this kind of problem.</p>
<h2 id="counting-the-alphabets">Counting the Alphabets</h2>
<p>This is quite easy task and I didn’t make a seprate function for this</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// .. snip ..</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>input_per_worker<span class="op">.</span>into_iter()<span class="op">.</span>for_each(<span class="op">|</span>input_<span class="op">|</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// note: .into_iter() used because I want to move the ownership into</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//       the for_each()</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// preprare for sending</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> tx <span class="op">=</span> tx_main<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// prepare for listening</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// collect count</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> subtotal <span class="op">=</span> <span class="pp">HashMap::</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">usize</span><span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        input_<span class="op">.</span>chars()<span class="op">.</span>for_each(<span class="op">|</span>ch<span class="op">|</span> <span class="op">{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> ch<span class="op">.</span>is_alphabetic() <span class="op">{</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>                <span class="co">// note: this task actually only insensitive on ascii alphabets</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">// speed up 2x when using simple to_ascii_lowercase()</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>                <span class="co">// another option is</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>                <span class="co">// change s.chars() -&gt; s.to_lowercases().chars()</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>                <span class="co">// and use as it is.</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> lc <span class="op">=</span> ch<span class="op">.</span>to_ascii_lowercase()<span class="op">;</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">/*ch.to_lowercase().for_each(|lc|*/</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the following pattern was posted in</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>                <span class="co">// https://jeongoon.github.io/posts/2022-05-20-exercism-org-raindrops.html#leave-it-as-basic</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>                <span class="kw">match</span> subtotal<span class="op">.</span>entry(lc) <span class="op">{</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>                    Occupied(o) <span class="op">=&gt;</span> <span class="op">*</span>o<span class="op">.</span>into_mut() <span class="op">+=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>                    Vacant(v) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>                        v<span class="op">.</span>insert(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="co">/*);*/</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// finally sending</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>        tx<span class="op">.</span>send(subtotal)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    handles<span class="op">.</span>push(handle)<span class="op">;</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h3 id="to_lowercase-or-to_ascii_lowercase">to_lowercase() or to_ascii_lowercase()</h3>
<p>As I mentioned as a comment, there are some issues with lower case. In short,</p>
<ul>
<li>If you need to apply lower case on whole <em>unicode</em> string: go for <a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase">str::to_lowercase</a></li>
<li>otherwise use <code class="verbatim">char::to_ascii_lowercase</code> or <code class="verbatim">str::to_ascii_lowercase</code>.</li>
</ul>
<p><em>I used char::to_ascii_lowercase() because I’d like to filter first (is_alphabetic()), and then apply</em></p>
<h2 id="finally-summerizing">Finally Summerizing</h2>
<p>fold() could be handy when you are only asked to for the final result. And naturally
we don’t need to worry about ownership and lifetime on the accumulator thanks to nature
of functional programming. I took the fold() again here.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// .. snip</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    handles<span class="op">.</span>iter()<span class="op">.</span>fold(<span class="pp">HashMap::</span>new()<span class="op">,</span> <span class="op">|</span><span class="kw">mut</span> acc<span class="op">,</span> _handle<span class="op">|</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        rx_main</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>recv()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>iter()</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>for_each(<span class="op">|</span>(<span class="op">&amp;</span>ch<span class="op">,</span> <span class="op">&amp;</span>count)<span class="op">|</span> <span class="kw">match</span> acc<span class="op">.</span>entry(ch) <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>                Occupied(o) <span class="op">=&gt;</span> <span class="op">*</span>o<span class="op">.</span>into_mut() <span class="op">+=</span> count<span class="op">,</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                Vacant(v) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                    v<span class="op">.</span>insert(count)<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        acc</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// end of pub fn frequency()</span></span></code></pre></div>
<h2 id="brief-benchmark">Brief Benchmark</h2>
<p>This task comes with benchmark code as well and the the following is one of my benchmark
on 9 years old xps.</p>
<div class="sourceCode" id="cb15" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>   <span class="ex">Compiling</span> parallel-letter-frequency v0.0.0 <span class="er">(</span><span class="ex">/home/myoungjin/exercism/rust/parallel-letter-frequency</span><span class="kw">)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Finished</span> bench [optimized] target<span class="er">(</span><span class="ex">s</span><span class="kw">)</span> <span class="er">in</span> <span class="ex">1.48s</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>     <span class="ex">Running</span> unittests src/lib.rs <span class="er">(</span><span class="ex">target/release/deps/parallel_letter_frequency-016160b8c250f033</span><span class="kw">)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ex">running</span> 0 tests</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="ex">0</span> failed<span class="kw">;</span> <span class="ex">0</span> ignored<span class="kw">;</span> <span class="ex">0</span> measured<span class="kw">;</span> <span class="ex">0</span> filtered out<span class="kw">;</span> <span class="ex">finished</span> in 0.00s</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>     <span class="ex">Running</span> benches/benchmark.rs <span class="er">(</span><span class="ex">target/release/deps/benchmark-15a648eb6d4b6f2b</span><span class="kw">)</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="ex">running</span> 6 tests</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> bench_large_parallel   ... bench:     279,074 ns/iter <span class="er">(</span><span class="ex">+/-</span> 37,084<span class="kw">)</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> bench_large_sequential ... bench:     661,265 ns/iter <span class="er">(</span><span class="ex">+/-</span> 14,291<span class="kw">)</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> bench_small_parallel   ... bench:      68,663 ns/iter <span class="er">(</span><span class="ex">+/-</span> 3,665<span class="kw">)</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> bench_small_sequential ... bench:      22,776 ns/iter <span class="er">(</span><span class="ex">+/-</span> 489<span class="kw">)</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> bench_tiny_parallel    ... bench:      60,142 ns/iter <span class="er">(</span><span class="ex">+/-</span> 3,124<span class="kw">)</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> bench_tiny_sequential  ... bench:          78 ns/iter <span class="er">(</span><span class="ex">+/-</span> 3<span class="kw">)</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="ex">0</span> failed<span class="kw">;</span> <span class="ex">0</span> ignored<span class="kw">;</span> <span class="ex">6</span> measured<span class="kw">;</span> <span class="ex">0</span> filtered out<span class="kw">;</span> <span class="ex">finished</span> in 21.73s</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h3 id="parallel-is-not-always-helpful-_병렬처리">parallel is not always helpful _병렬처리</h3>
<p>We could gain some time efficiency on first <em>bench_large_parallel</em> test case
from the concurrency, wel.. the other benchmarks do not show the benefit at all.</p>
<p>Because there are some overhead to make thread(s), we should be be careful on applying
parallel or concurrency</p>
<p>The bench marking is pretty wise way to learn something to see the what we can earn or
lose by using some sort of methods.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>This is quite long article, due to the subject. But I’d like to share my thoughts
on concurrency:</p>
<ul>
<li><p>Once you making the threads, think about how to reap as well.</p></li>
<li><p>Communication between the threads is an important factor of concurrency.</p>
<ul>
<li>Message passing - which isn’t expensive at all compared to using return from a thread</li>
<li>Shared memory - could be useful, requires more resource, not dangerous in rust.</li>
</ul></li>
<li><p>Use the concurrency wisely</p>
<ul>
<li>benchmarking is important to see the effect objectively</li>
<li>Less thread and less ownership makes less overhead</li>
<li>but don’t be afraid, rust won’t compile the thread-<em>unsafe</em> code.</li>
</ul></li>
</ul>

    </div>

    <footer id="main-footer">
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
  </body>
</html>

<!--
    Todo:
    add basic parallax and add some gradation??
    
    -->
